# TECHSPEC: симулятор игры

## 1. Цель

Нужно написать консольную программу на Python 3.11/3.12, которая:
- читает правила игры из JSON-конфига
- симулирует много партий (10k-100k)
- собирает статистику по VP, частоте паттернов, применению наград
- поддерживает несколько агентов (стратегий)
- поддерживает fallback для невалидных решений агента: случайный валидный выбор с логированием

Единый источник правил:
- config/game_rules_config_v0_1.json

## 2. Входные данные

JSON-конфиг содержит:
- параметры игроков: 2..4, ход по часовой стрелке, следующий игрок слева
- колоду 90 уникальных карт (rank 1..6, color 1..5, shape 1..3)
- поле 5x5 с защищенной зоной центр 3x3
- драфт: открыть 3, одну себе, одну следующему игроку, одну в сброс
- паттерны A-J (shape, rank_rule, color_rule, vp, reward_id)
- награды RWD1..RWD10 (optional, ограничения защищенной зоны)
- правила окончания партии
- fallback_policy: random_valid_with_logging

## 3. Ключевые правила игры

### 3.1. Ход игрока

Ход состоит из двух фаз.

Фаза 1: размещение карт из руки
- игрок обязан разместить все карты из руки, по одной
- после каждого размещения запускается цикл автопаттернов (раздел 3.3)
- игрок не может остановиться добровольно
- если нет свободных клеток для обязательного размещения карты из руки, партия заканчивается немедленно (END2)

Фаза 2: драфт
- перед началом фазы 2 требуется, чтобы в колоде было минимум 3 карты
- если в колоде меньше 3 карт, партия заканчивается немедленно (END1)
- иначе:
  - открыть 3 карты с верха колоды
  - игрок выбирает 1 карту себе
  - из оставшихся двух:
    - одну карту передает следующему игроку по порядку хода (слева)
    - одну карту кладет в сброс
  - выбранную себе карту игрок обязан разместить на поле
  - если нет свободных клеток для обязательного размещения выбранной карты, партия заканчивается немедленно (END2)
  - после размещения запускается цикл автопаттернов

### 3.2. Пустая колода

- если колода стала пустой после завершения фазы 2 на чьем-то ходе, партия автоматически не заканчивается
- следующий игрок все равно может выполнить фазу 1 (размещение всех карт из руки)
- как только любой игрок завершает фазу 1 и пытается начать фазу 2, при колоде < 3 срабатывает END1
- награда extra_turn игнорируется, если колода пуста

### 3.3. Паттерны: автосрабатывание и очистка

- паттерны срабатывают автоматически, решения "сбрасывать или нет" нет
- при разрешении паттерна:
  1) начислить игроку VP за паттерн
  2) предложить применить награду паттерна или отказаться (награда опциональна)
  3) удалить карты паттерна с поля игрока и положить их в общий сброс (паттерн очищается)
- если одновременно найдено несколько паттернов:
  - порядок разрешения выбирает агент
  - паттерны разрешаются последовательно
  - после каждого разрешения выполняется повторный поиск паттернов, пока паттернов нет

### 3.4. Награды

- все награды опциональны, игрок может отказаться от эффекта
- если игрок решил применить награду, но действие невозможно, награда считается непримененной без штрафов
- если награда требует разместить карту (из сброса, украсть, джокер), но свободных клеток нет:
  - награда просто не применяется
  - партия не заканчивается
- награда skip_turn действует только на следующего игрока (слева) и пропускает весь ход целиком
  - пропуск означает: не выполняется ни фаза 1, ни фаза 2
  - карты в руке сохраняются до следующего неперепущенного хода
- действия на оппоненте (RWD6/RWD7/RWD10) разрешены на любого оппонента
- ограничения защищенной зоны оппонента:
  - нельзя выбирать карту-источник внутри защищенной зоны оппонента
  - нельзя выбирать клетку-цель внутри защищенной зоны оппонента
  - нельзя перемещать карты в защищенную зону оппонента и из нее
  - владелец поля может свободно двигать и удалять свои карты внутри своей защищенной зоны и в/из нее

### 3.5. Джокер

- джокер занимает клетку на поле как обычная карта
- для проверки паттерна джокер может считаться картой с любым rank и любым color
- значения rank/color назначаются только для проверки и не сохраняются

## 4. Паттерны A-J

Используются только правила rank и color, shape игнорируется.

Определения ранговых правил:
- R1_line_sequence_step1: линия длины L (4 или 5), ранги подряд с шагом 1, допускается возрастание и убывание
- R2_line_all_equal: все ранги в линии одинаковые
- R3_square_stripes: квадрат 3x3, по одной оси ранги подряд с шагом 1, по другой оси ранги постоянны полосами
- R4_square_two_axes: квадрат 3x3, ранги меняются по обеим осям с шагом 1: rank(x,y) = r0 + dx*x + dy*y, dx,dy в {+1,-1}

Определения цветовых правил:
- C1_line_monochrome: все карты линии одного цвета
- C2_line_all_distinct: все цвета в линии различны (для длины 5 это все 5 цветов, для длины 4 это 4 разных цвета из 5)
- C3_square_flag: квадрат 3x3, либо строки-монохром и 3 разных цвета строк, либо столбцы-монохром и 3 разных цвета столбцов
- C4_square_latin: квадрат 3x3, в каждой строке 3 разных цвета и в каждом столбце 3 разных цвета

Привязка A-J:
- A: square_3x3, R3_square_stripes, C3_square_flag
- B: square_3x3, R3_square_stripes, C4_square_latin
- C: square_3x3, R4_square_two_axes, C3_square_flag
- D: square_3x3, R4_square_two_axes, C4_square_latin
- E: line_len_5, R1_line_sequence_step1, C1_line_monochrome
- F: line_len_5, R1_line_sequence_step1, C2_line_all_distinct
- G: line_len_5, R2_line_all_equal, C2_line_all_distinct
- H: line_len_4, R1_line_sequence_step1, C1_line_monochrome
- I: line_len_4, R1_line_sequence_step1, C2_line_all_distinct
- J: line_len_4, R2_line_all_equal, C2_line_all_distinct

VP и награды берутся из JSON-конфига.

## 5. Агенты

Нужно реализовать минимум 3 агента.

1) RandomAgent
- все решения случайны из валидных

2) GreedyVPAgent
- выбирает размещения и решения по наградам, которые максимизируют немедленный прирост VP и вероятность собрать паттерн в ближайшие 1-2 шага (простая эвристика)

3) DisruptorAgent
- использует награды для воздействия на оппонентов, ориентируется на лидера по VP, но не ломает себе обязательные размещения

Интерфейс агента:
- choose_placement_cell(state, card)
- choose_draft_pick(state, revealed_cards)
- choose_draft_pass(state, remaining_cards)
- choose_pattern_to_resolve(state, found_patterns)
- choose_apply_reward(state, reward, context) -> bool
- choose_reward_params(state, reward, context) -> dict

Если агент вернул невалидный выбор:
- использовать fallback: случайный валидный выбор
- логировать событие (тип решения, агент, причина)

## 6. Архитектура кода

Рекомендуемая структура:
- config_loader.py (парсинг JSON + валидация enum)
- models.py (Card, Joker, PlayerState, GameState, PatternMatch)
- pattern_engine.py (поиск паттернов по правилам)
- reward_engine.py (применение наград и ограничений)
- game_engine.py (фазы хода, окончание партии, очередь extra_turn)
- agents/ (random_agent.py, greedy_vp_agent.py, disruptor_agent.py)
- simulator.py (запуск N партий, сбор статистики)
- reports.py (агрегации, экспорт в json/csv)
- main.py (CLI)

## 7. Метрики и отчеты

После серии симуляций нужно вывести:
- средние, медианные VP по агентам, std, p90
- winrate по агентам
- частоты паттернов A-J
- частоты применений наград RWD1..RWD10 и частоты отказов
- средняя длина партии в ходах
- причины окончания партии: END1 и END2
- количество срабатываний fallback

## 8. CLI

Пример запуска:
python -m src.main --config config/game_rules_config_v0_1.json --players 3 --games 50000 --seed 123 --agents random greedy disruptor --out results.json

Аргументы:
- --config путь к JSON-конфигу
- --players 2..4
- --games количество партий
- --seed seed генератора случайных чисел
- --agents список агентов (по одному на игрока)
- --out путь для сохранения json-отчета

## 9. Критерии готовности

- симулятор воспроизводим при фиксированном seed
- все правила окончания партии реализованы строго (END1, END2, пустая колода, extra_turn)
- защищенная зона влияет на допустимость действий оппонентов
- паттерны корректно детектятся и очищаются
- есть отчеты и базовые агенты
